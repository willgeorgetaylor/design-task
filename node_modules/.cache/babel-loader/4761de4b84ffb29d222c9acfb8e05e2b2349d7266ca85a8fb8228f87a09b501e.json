{"ast":null,"code":"import { getSecondsInUnit } from './units';\nimport { getRoundFunction, getDiffRatioToNextRoundedNumber } from '../round';\n/**\r\n * Gets the time to next update for a step with a time unit defined.\r\n * @param  {string} unit\r\n * @param  {number} date — The date passed to `.format()`, converted to a timestamp.\r\n * @param  {number} options.now\r\n * @param  {string} [options.round] — (undocumented) Rounding mechanism.\r\n * @return {number} [timeToNextUpdate]\r\n */\n\nexport default function getTimeToNextUpdateForUnit(unit, timestamp, _ref) {\n  var now = _ref.now,\n    round = _ref.round;\n\n  // For some units, like \"now\", there's no defined amount of seconds in them.\n  if (!getSecondsInUnit(unit)) {\n    // If there's no amount of seconds defined for this unit\n    // then the update interval can't be determined reliably.\n    return;\n  }\n  var unitDenominator = getSecondsInUnit(unit) * 1000;\n  var future = timestamp > now;\n  var preciseAmount = Math.abs(timestamp - now);\n  var roundedAmount = getRoundFunction(round)(preciseAmount / unitDenominator) * unitDenominator;\n  if (future) {\n    if (roundedAmount > 0) {\n      // Amount decreases with time.\n      return preciseAmount - roundedAmount + getDiffToPreviousRoundedNumber(round, unitDenominator);\n    } else {\n      // Refresh right after the zero point,\n      // when \"future\" changes to \"past\".\n      return preciseAmount - roundedAmount + 1;\n    }\n  } // Amount increases with time.\n\n  return -(preciseAmount - roundedAmount) + getDiffToNextRoundedNumber(round, unitDenominator);\n}\nfunction getDiffToNextRoundedNumber(round, unitDenominator) {\n  return getDiffRatioToNextRoundedNumber(round) * unitDenominator;\n}\nfunction getDiffToPreviousRoundedNumber(round, unitDenominator) {\n  return (1 - getDiffRatioToNextRoundedNumber(round)) * unitDenominator + 1;\n}","map":{"version":3,"names":["getSecondsInUnit","getRoundFunction","getDiffRatioToNextRoundedNumber","getTimeToNextUpdateForUnit","unit","timestamp","_ref","now","round","unitDenominator","future","preciseAmount","Math","abs","roundedAmount","getDiffToPreviousRoundedNumber","getDiffToNextRoundedNumber"],"sources":["/Users/will/Desktop/design-task/node_modules/.pnpm/javascript-time-ago@2.3.7/node_modules/javascript-time-ago/source/steps/getTimeToNextUpdateForUnit.js"],"sourcesContent":["import { getSecondsInUnit } from './units'\r\nimport { getRoundFunction, getDiffRatioToNextRoundedNumber } from '../round'\r\n\r\n/**\r\n * Gets the time to next update for a step with a time unit defined.\r\n * @param  {string} unit\r\n * @param  {number} date — The date passed to `.format()`, converted to a timestamp.\r\n * @param  {number} options.now\r\n * @param  {string} [options.round] — (undocumented) Rounding mechanism.\r\n * @return {number} [timeToNextUpdate]\r\n */\r\nexport default function getTimeToNextUpdateForUnit(unit, timestamp, { now, round }) {\r\n\t// For some units, like \"now\", there's no defined amount of seconds in them.\r\n\tif (!getSecondsInUnit(unit)) {\r\n\t\t// If there's no amount of seconds defined for this unit\r\n\t\t// then the update interval can't be determined reliably.\r\n\t\treturn\r\n\t}\r\n\tconst unitDenominator = getSecondsInUnit(unit) * 1000\r\n\tconst future = timestamp > now\r\n\tconst preciseAmount = Math.abs(timestamp - now)\r\n\tconst roundedAmount = getRoundFunction(round)(preciseAmount / unitDenominator) * unitDenominator\r\n\tif (future) {\r\n\t\tif (roundedAmount > 0) {\r\n\t\t\t// Amount decreases with time.\r\n\t\t\treturn (preciseAmount - roundedAmount) +\r\n\t\t\t\tgetDiffToPreviousRoundedNumber(round, unitDenominator)\r\n\t\t} else {\r\n\t\t\t// Refresh right after the zero point,\r\n\t\t\t// when \"future\" changes to \"past\".\r\n\t\t\treturn (preciseAmount - roundedAmount) + 1\r\n\t\t}\r\n\t}\r\n \t// Amount increases with time.\r\n\treturn -(preciseAmount - roundedAmount) + getDiffToNextRoundedNumber(round, unitDenominator)\r\n}\r\n\r\nfunction getDiffToNextRoundedNumber(round, unitDenominator) {\r\n\treturn getDiffRatioToNextRoundedNumber(round) * unitDenominator\r\n}\r\n\r\nfunction getDiffToPreviousRoundedNumber(round, unitDenominator) {\r\n\treturn (1 - getDiffRatioToNextRoundedNumber(round)) * unitDenominator + 1\r\n}"],"mappings":"AAAA,SAASA,gBAAT,QAAiC,SAAjC;AACA,SAASC,gBAAT,EAA2BC,+BAA3B,QAAkE,UAAlE;AAEA;;;;;;;;;AAQA,eAAe,SAASC,0BAATA,CAAoCC,IAApC,EAA0CC,SAA1C,EAAAC,IAAA,EAAqE;EAAA,IAAdC,GAAc,GAAAD,IAAA,CAAdC,GAAc;IAATC,KAAS,GAAAF,IAAA,CAATE,KAAS;;EACnF;EACA,IAAI,CAACR,gBAAgB,CAACI,IAAD,CAArB,EAA6B;IAC5B;IACA;IACA;EACA;EACD,IAAMK,eAAe,GAAGT,gBAAgB,CAACI,IAAD,CAAhB,GAAyB,IAAjD;EACA,IAAMM,MAAM,GAAGL,SAAS,GAAGE,GAA3B;EACA,IAAMI,aAAa,GAAGC,IAAI,CAACC,GAAL,CAASR,SAAS,GAAGE,GAArB,CAAtB;EACA,IAAMO,aAAa,GAAGb,gBAAgB,CAACO,KAAD,CAAhB,CAAwBG,aAAa,GAAGF,eAAxC,IAA2DA,eAAjF;EACA,IAAIC,MAAJ,EAAY;IACX,IAAII,aAAa,GAAG,CAApB,EAAuB;MACtB;MACA,OAAQH,aAAa,GAAGG,aAAjB,GACNC,8BAA8B,CAACP,KAAD,EAAQC,eAAR,CAD/B;IAEA,CAJD,MAIO;MACN;MACA;MACA,OAAQE,aAAa,GAAGG,aAAjB,GAAkC,CAAzC;IACA;EACD,CArBkF,CAsBlF;;EACD,OAAO,EAAEH,aAAa,GAAGG,aAAlB,IAAmCE,0BAA0B,CAACR,KAAD,EAAQC,eAAR,CAApE;AACA;AAED,SAASO,0BAATA,CAAoCR,KAApC,EAA2CC,eAA3C,EAA4D;EAC3D,OAAOP,+BAA+B,CAACM,KAAD,CAA/B,GAAyCC,eAAhD;AACA;AAED,SAASM,8BAATA,CAAwCP,KAAxC,EAA+CC,eAA/C,EAAgE;EAC/D,OAAO,CAAC,IAAIP,+BAA+B,CAACM,KAAD,CAApC,IAA+CC,eAA/C,GAAiE,CAAxE;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}